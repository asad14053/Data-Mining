import random
def calculate_distance(x,y,z,m,n,o):
    #for w1 in range(10):
    w1 = 1
    w2 = 1
    w3 = 1
    d = (w1*(x-m)**2+w2*(y-n)**2+w3*(z-o)**2)**0.5
    return d
def k3_means(name,h,b,a):
    r0 = [0]*3 #representing point of group 1
    r1 = [0]*3
    r2 = [0]*3
    #d1 = [0]*len(h)
    #d2 = [0]*len(h)
    group = [0]*len(h)
    r0p = random.randint(0,len(h)-1)
    r1p = r0p
    r2p = r0p
    while r1p == r0p:
        r1p = random.randint(0,len(h)-1)
    while r2p == r0p or r2p == r1p:
        r2p = random.randint(0,len(h)-1)
    r0 = [h[r0p],b[r0p],a[r0p]]
    r1 = [h[r1p],b[r1p],a[r1p]]
    r2 = [h[r2p],b[r2p],a[r2p]]
    print(r0p,r1p,r2p, name[r0p],name[r1p],name[r2p])
    for i in range(10): #no. of iterations
        print('iteration: ',i)
        print(r0)
        print(r1)
        print(r2)
        n0 = 0
        n1 = 0
        n2 = 0
        for j in range(len(h)): #no. of items/individuals
            d0 = calculate_distance(r0[0], r0[1], r0[2], h[j],b[j],a[j])
            d1 = calculate_distance(r1[0], r1[1], r1[2], h[j],b[j],a[j])
            d2 = calculate_distance(r2[0], r2[1], r2[2], h[j], b[j], a[j])
            if d0 == min(d0,d1,d2):
                group[j] = 0
                n0+=1
            elif d1 == min(d0,d1,d2):
                group[j] = 1
                n1+=1
            else:
                group[j] = 2
                n2+=1
        print(name)
        print(group)
        r0 = [0]*3
        r1 = [0]*3
        r2 = [0]*3
        for j in range(len(h)):
            if group[j] == 0:
                r0[0] += h[j] / n0
                r0[1] += b[j] / n0
                r0[2] += a[j] / n0
            elif group[j] == 1:
                r1[0] += h[j] / n1
                r1[1] += b[j] / n1
                r1[2] += a[j] / n1
            elif group[j] == 2:
                r2[0] += h[j] / n2
                r2[1] += b[j] / n2
                r2[2] += a[j] / n2
def k2_means(name,h,b,a):
    r1 = [0]*3 #representing point of group 1
    r2 = [0]*3
    #d1 = [0]*len(h)
    #d2 = [0]*len(h)
    group = [0]*len(h)
    r0p = random.randint(0,len(h)-1)
    r1p = r0p
    while r1p == r0p:
        r1p = random.randint(0,len(h)-1)
    r0 = [h[r0p],b[r0p],a[r0p]]
    r1 = [h[r1p],b[r1p],a[r1p]]
    print(r0p,r1p, name[r0p],name[r1p])
    for i in range(10): #no. of iterations
        print('iteration: ',i)
        print(r0)
        print(r1)
        n0 = 0
        n1 = 0
        for j in range(len(h)): #no. of items/individuals
            d0 = calculate_distance(r0[0], r0[1], r0[2], h[j],b[j],a[j])
            d1 = calculate_distance(r1[0], r1[1], r1[2], h[j],b[j],a[j])
            if d0 < d1:
                group[j] = 0
                n0+=1
            else:
                group[j] = 1
                n1+=1
        print(name)
        print(group)
        r0 = [0]*3
        r1 = [0]*3
        for j in range(len(h)):
            if group[j] == 0:
                r0[0] += h[j] / n0
                r0[1] += b[j] / n0
                r0[2] += a[j] / n0
            elif group[j] == 1:
                r1[0] += h[j] / n1
                r1[1] += b[j] / n1
                r1[2] += a[j] / n1

def hierachy(name,h,b,a):
    n = len(name)
    w = [1]*n
    for i in range(n-1):
        shortest = 1000
        p1 = 0
        p2 = 0
        for j in range(n-i):
            for k in range(j):
                dist = calculate_distance(h[j],b[j],a[j],h[k],b[k],a[k])
                if dist < shortest:
                    shortest = dist
                    p1 = k
                    p2 = j
        print('note 1: ',shortest, p1, p2,name[p1],name[p2])
        name[p1] = name[p1]+':'+name[p2]
        h[p1] = (h[p1]*w[p1]+h[p2]*w[p2])/(w[p1]+w[p2])
        b[p1] = (b[p1]*w[p1]+b[p2]*w[p2])/(w[p1]+w[p2])
        a[p1] = (a[p1]*w[p1]+a[p2]*w[p2])/(w[p1]+w[p2])
        w[p1] = w[p1]+w[p2]
        del name[p2]
        del h[p2]
        del b[p2]
        del a[p2]
        del w[p2]
        print(name)
        print(h)
        print(b)
        print(a)
        print(w)
        xxx = input()
def k3nn(name,h,b,a,g):
    n = len(name)
    pred = ['X']*n
    closest_3 = [-1]*3
    tp = 0
    for i in range(n): #cross-validation
        nearest = [1000,1000,1000]
        for j in range(n):
            if i == j:
                continue
            else:
                d = calculate_distance(h[i],b[i],a[i], h[j],b[j],a[j])
                if d < nearest[0]:
                    nearest[2] = nearest[1]
                    nearest[1] = nearest[0]
                    nearest[0] = d
                    closest_3[2] = closest_3[1]
                    closest_3[1] = closest_3[0]
                    closest_3[0] = j
                elif d< nearest[1]:
                    nearest[2] = nearest[1]
                    nearest[1] = d
                    closest_3[2] = closest_3[1]
                    closest_3[1] = j
                elif d<nearest[2]:
                    nearest[2] = d
                    closest_3[2] = j
        nof_m = 0
        for k in range(3):
            if g[closest_3[k]] == 'M':
                nof_m+=1
        if nof_m > 1:
            pred[i] = 'M'
        else:
            pred[i] = 'F'
        if pred[i] == g[i]:
            tp+=1
        print(name[i],g[i],name[closest_3[0]],g[closest_3[0]],name[closest_3[1]],g[closest_3[1]],name[closest_3[2]],g[closest_3[2]],pred[i])
    print("3-NN Accuracy=  ",tp/n*100 )
def k1nn(name,h,b,a,g):
    n = len(name)
    pred = ['X']*n
    closest_1 = [-1]*n
    tp = 0
    for i in range(n): #cross-validation
        nearest = 1000
        for j in range(n):
            if i == j:
                continue
            else:
                d = calculate_distance(h[i],b[i],a[i], h[j],b[j],a[j])
                if d < nearest:
                    nearest = d
                    closest_1[i] = j
        if g[closest_1[i]] == g[i]:
            tp+=1
        pred[i] = g[closest_1[i]]
        print(name[i],g[i],name[closest_1[i]],g[closest_1[i]],pred[i])
    print("1-nn Accuracy=  ",tp/n*100 )
def main():
    name = ['Paul','Denis','Hayat','Ja-kyung','Jaemin','Jongwha','Keith','Asad','Oscar','Ravi','Xinyu','Yuechen']
    gender = ['M','M','F','F','M','M','M','M','M','M','F','M']
    h = [70,72,63,64,72,69,68,80,67,73,63,72] #height
    bw = [175,181,132,120,210,143,190,124,155,181,128,185] #weight
    age = [45,40,40,29,28,27,29,26,27,28,26,24]
    #w = [1]*len(name)
    #hierachy(name,h,bw,age)
    #k2_means(name,h,bw,age)
    #k3_means(name,h,bw,age)
    k1nn(name,h,bw,age,gender)
    k3nn(name,h,bw,age,gender)
def lottory():
    name = ['Keith','Paul','Hayat','Yuechen'] #['Denis+Ravi', 'Hayat+Keith', 'Ja-kyung+Johnwha+Jaemin', 'Asad', 'Oscar', 'Xinyu+Yuechen']
    for i in range(4):
        n = random.choice(name)
        print(n)
        name.remove(n)

#lottory()
main()